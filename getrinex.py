
# -*- coding: utf-8 -*-
"""
Created on Mon Feb  1 08:12:26 2021

@author: Michael
"""


# from csv import reader
# import csv
# import codecs
import iso8601
import pytz
from datetime import datetime
# import logging
import pandas as pd
import os
import gui_parsenmea as gui
import tqdm
import re

class ReadNmea:
    
    def __init__(self, sourcefile):
        self.sourcefile = sourcefile
        self.timestamp = None
        self.posMode = 'Missing'
        self.time = None
        self.exist_file = False
        self.receiver_name = None
        self.no_date = True
        # The time is syncronizde on the zda time. 
        self.db_path = 'C:/SwisstopoMobility/analysis/DataBase'
        
        if 'sapcorda' in self.sourcefile:
            self.receiver_name = 'sapcorda.nmea'
        elif 'swipos' and 'ublox' in self.sourcefile:
            self.receiver_name = 'swipos_ublox.nmea'
        elif 'swipos' and ('UART' or 'uart') in self.sourcefile:
            self.receiver_name = 'swipos_ublox_uart.nmea'
        elif 'netR9' or 'NetR9' or 'netr9' in self.sourcefile:
            self.receiver_name = 'swipos_NetR9.nmea'
        else:
            self.recevier_name = 'unkown.csv'
            
        basename = os.path.basename(self.sourcefile)

        try:
            date = basename[0:10]
            self.date = datetime.strptime(date, '%Y-%m-%d')
        except Exception as e:
            # print(e)
            pass
        try:
            date = basename[0:10]
            self.date = datetime.strptime(date, '%d-%m-%Y')
        
        except Exception as e:
            # print(e)
            # print(date, ':()')
            pass
        
    
    
    def parser(self):
        
        # Open file in read mode as bytes'
        with open(self.sourcefile, 'rb') as read_obj:
            
            byte_line = read_obj.readline()
            
            while self.no_date:

   
                # keep only valid nmea (as string)
                str_line = self.search_nmea(byte_line)
                
                # Skip on None type object
                if str_line==None:
                    # Advanced of one line
                    byte_line = read_obj.readline()
                    continue 
                
                # remove chesum from nmea message 
                str_line[-1], cksum = str_line[-1].split('*')
                
                # singular case
                if str_line[0][-3:].lower()=='bs':
                    continue
                
                # select message name and function
                getattr(ReadNmea, str_line[0][-3:].lower())(self, str_line)
                
                # extract index
                index = self.df.index
                
                '''check if the line as been fully filled
                
                This help to reduce the neccessary flash memory used to
                process this code by just keep one output line at the 
                time. 
                
                '''
                if len(index)>1:
                    # open File
                    if not self.exist_file:
                        file_name = self.openfile()
                        self.exist_file = True
                    # Write the line in file
                    self.writefile(file_name, index[-2])
                    # Drop the saved row
                    self.df = self.df.drop(index[-2])

                # Advanced of one line
                byte_line = read_obj.readline()

        return self.timestamp
    
    def search_nmea(self, byte_line):
        # /!\ I suppose there is maximum one correct nmea msg pro line
        
        # Initialize of parameters
        nmea=None # output
        i = 0   # index
        # look for '$' sign in the byte string 
        for x in re.split(b'\$', byte_line):
            # catch only nmea message 
            try:
                # skip empty 'x' generated by 're.split'
                if x==b'':
                    continue
                else:
                    str_line = x.decode('utf-8')
                    
            except:
                continue
            
            # some ubx messages still get decoded
            # This dictionnary try to remove them
            if str_line.find('\x00')!= -1:
                continue
            
            elif str_line.find('\x01')!=-1:
                continue
            elif str_line.find('\x02')!=-1:
                continue
            elif str_line.find('\x03')!=-1:
                continue
            elif str_line.find('\x04')!=-1:
                continue
            elif str_line.find('\x05')!=-1:
                continue
            elif str_line.find('\x06')!=-1:
                continue
            elif str_line.find('\x07')!=-1:
                continue
            elif str_line.find('\x08')!=-1:
                continue
            elif str_line.find('\x09')!=-1:
                continue
            elif str_line.find('\x09')!=-1:
                continue
            elif str_line.find('\x11')!=-1:
                continue
            elif str_line.find('\x1a')!=-1:
                continue
            
            line = re.split(',', str_line)
            # Check nma validityy
            if self.checksum(','.join(line)):
                # Save nmea message in a list
                # print(line)
                nmea = line
                return nmea
         
        return nmea

    
    def checksum(self, nmea_msg):
        
        if nmea_msg == '':
            return False

        # message without '*' are considered invalid
        try:
            # split the message and the cheksum
            cksumdata, cksum = nmea_msg.split('*')
            # remove first charachter '$'
            # empty, cksumdata = cksumdata.split('$')
            
        except Exception as e:
            # print(e, ': ', nmea_msg, 'La vita Ã¨ bella')
            self.count_invalid += 1
            return False 
        
        # Some times the EOL charaters is missing
        try:
            # remove EOL charachter '\r\n'
            cksum, eol = cksum.split('\r\n')
        except Exception as e:
            # print(e, ': ', nmea_msg)
            pass
            
       
            
        # cksum with more than two digit are considered invalid
        if len(cksum) > 3:
            self.count_invalid +=1
            return False
        
        # cksum wich are not base 16 are considered invalid
        try:
            int(cksum, 16)
        except Exception as e:
            # print(e, ': ', nmea_msg)
            self.count_invalid += 1
            return False 
        
        
        # Initializing first XOR value
        csum = 0 
        for c in cksumdata:
            # XOR'ing value of csum against the next char in line
            # and storing the new XOR value in csum
           csum ^= ord(c)
        
        # if csum is equal do cksum the message is valid
        if hex(csum) == hex(int(cksum, 16)):
            
            self.count_valid += 1
            return True
    
        else:
            self.count_invalid += 1
            return False

        
    def utcrcf3339(self,_date):
        _date_obj = iso8601.parse_date(_date)
        _date_utc = _date_obj.astimezone(pytz.utc)
        _date_utc_zformat = _date_utc.strftime('%Y-%m-%dT%H:%M:%SZ')
        return _date_utc_zformat

    def zda(self, row):
        # Message: Time and date
        
        # ZDA message exemple:
        #
        #   __________________________________
        #  |__0__|_1__|_2_|__3__|_4__|___5____|
        #  | Name|time|day|month|year|timezone|
        # ['$GNZDA', '120008.02', '27', '12', '2020', '00', '00*77']
    

        # Create a UTC RCF3339 timestamp
        _date=row[4] + row[3] + row[2] + 'T' + row[1]
        # print(_date)
        # print(row[1]!='' and row[2]!='' and row[3]!='' and row[4]!='')
        # Exit if empty date
        if row[1]!='' and row[2]!='' and row[3]!='' and row[4]!='':
            self.timestamp = self.utcrcf3339(_date)
            self.time = row[1]
            
            # As the first zda mesage is arrived change the flag name
            self.no_date = False
        

    def gns(self, row):
        
        pass               
               
    def gsa(self, row):
        pass
        
    def gst(self, row):
        pass
        
    def dtm(self, row):
        pass
    def rmc(self, row):
        pass
    
    def vtg(self, row):
        pass
    
    def gga(self, row):
        pass
        #
    def gbs(self, row):

        pass

    def gsv(self, row):

        pass
    
    def gll(self, row):
        #### NOT IMPLEMENTED YET####
        pass

class get_rinex:
    def __init__(self, timestamp):
        self.timestamp = timestamp
        
    def do_rinex(self):
        mjd = self.mjd(self.timestamp)
        
# receiver = ReadNmea('.\\2021\\January\\04\\2021-01-04_sapcorda_ubx.ubx')
# df = receiver.parser()
class Batch:
    def __init__(self, foldername):
        self.foldername1 = foldername
        # self.count = 1
        # self.numFiles = self.countFiles(foldername)
        
        print('Start process\n\n')
        
    def scanDir(self):

        for entry in os.scandir(self.foldername1):
            if os.path.isdir(entry.path):
                self.foldername1 = entry
                self.scanDir()
            
            if os.path.isfile(entry.path):
                root, extension = os.path.splitext(entry.path)
                if extension == '.txt' and root.find('netR9') != -1:
                    print(f'File that is parsing {os.path.basename(entry)}: ')
                    receiver = ReadNmea(entry.path)
                    date = receiver.parser()
                    
                if extension == '.ubx':
                    print(f'File that is parsing {os.path.basename(entry)}: ')
                    receiver = ReadNmea(entry.path)
                    date = receiver.parser()
                    
            # print(f' {self.count}/{self.numFiles} files have been parsed\n\n')
            # self.count +=1

# Call the interface class
app = gui.Interface()
app.title('Parse UBX messages')
app.mainloop()
filepath = app.output()

# filepath = 'C:/SwisstopoMobility/analysis/DataBase/2021/January/29/2021-01-29_sapcorda_ubx.ubx'

# Executre once for the selcted file
if os.path.isfile(filepath):
    receiver = ReadNmea(filepath)
    print(filepath)
    date = receiver.parser()
    get_rinex(date)
    
# Iteration over all files in folder
if os.path.isdir(filepath):
    batch = Batch(filepath)
    batch.scanDir()
    print('End of batch process')